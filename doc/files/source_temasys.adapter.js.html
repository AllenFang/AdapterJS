<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>source/temasys.adapter.js - adapterjs</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="adapterjs" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.10.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/AdapterJS.html">AdapterJS</a></li>
                                <li><a href="../classes/WebRTCPlugin.html">WebRTCPlugin</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: source/temasys.adapter.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * The Temasys AdapterJS interface.
 * @class AdapterJS
 * @since 0.10.5
 */
window.AdapterJS = AdapterJS || {};

/**
 * Contains the options of the Temasys Plugin.
 * @property options
 * @param getAllCams {Boolean} Option to get virtual cameras.
 *   Override this value here.
 * @param hidePluginInstallPrompt {Boolean} Option to prevent
 *   the install prompt when the plugin in not yet installed.
 *   Override this value here.
 * @type JSON
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.options = {
  getAllCams: false,
  hidePluginInstallPrompt: false
};

/**
 * The current version of the Temasys AdapterJS.
 * @property VERSION.
 * @type String
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.VERSION = &#x27;@@version&#x27;;

/**
 * The event function that will be called when the WebRTC API is
 *   ready to be used in cross-browsers.
 * If you decide not to override use this synchronisation, it may result in
 *   an extensive CPU usage on the plugin start (once per tab loaded).
 * Override this function to synchronise the start of your application
 *   with the WebRTC API being ready.
 * @property onwebrtcready
 * @return {Boolean} Returns a boolean in the event function that
 *   indicates if the WebRTC plugin is being used, false otherwise.
 * @type Function
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.onwebrtcready = AdapterJS.onwebrtcready || function (isUsingPlugin) {};

/**
 * Checks if maybe WebRTC is already ready.
 * @property maybeThroughWebRTCReady
 * @type Function
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.maybeThroughWebRTCReady = function () {
  if (!AdapterJS.onwebrtcreadyDone) {
    AdapterJS.onwebrtcreadyDone = true;

    if (typeof AdapterJS.onwebrtcready === &#x27;function&#x27;) {
      AdapterJS.onwebrtcready(AdapterJS.WebRTCPlugin.plugin !== null);
    }
  }
};

/**
 * The result of ICE connection states.
 * @property _iceConnectionStates
 * @param {String} starting ICE connection is starting.
 * @param {String} checking ICE connection is checking.
 * @param {String} connected ICE connection is connected.
 * @param {String} completed ICE connection is connected.
 * @param {String} done ICE connection has been completed.
 * @param {String} disconnected ICE connection has been disconnected.
 * @param {String} failed ICE connection has failed.
 * @param {String} closed ICE connection is closed.
 * @type JSON
 * @readOnly
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS._iceConnectionStates = {
  starting : &#x27;starting&#x27;,
  checking : &#x27;checking&#x27;,
  connected : &#x27;connected&#x27;,
  completed : &#x27;connected&#x27;,
  done : &#x27;completed&#x27;,
  disconnected : &#x27;disconnected&#x27;,
  failed : &#x27;failed&#x27;,
  closed : &#x27;closed&#x27;
};

/**
 * The IceConnection states that has been fired for each peer.
 * @property _iceConnectionFiredStates
 * @param {Array} (#peerId) The ICE connection fired states for this peerId.
 * @type Array
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS._iceConnectionFiredStates = [];

/**
 * Check if WebRTC Interface is defined.
 * @property isDefined
 * @type Boolean
 * @readOnly
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.isDefined = null;

/**
 * This function helps to retrieve the webrtc detected browser information.
 * This sets:
 * webrtcDetectedBrowser: The browser agent name.
 * - webrtcDetectedVersion: The browser version.
 * - webrtcDetectedType: The types of webRTC support.
 *   - &#x27;moz&#x27;: Mozilla implementation of webRTC.
 *   - &#x27;webkit&#x27;: WebKit implementation of webRTC.
 *   - &#x27;plugin&#x27;: Using the plugin implementation.
 * @property parseWebrtcDetectedBrowser
 * @type Function
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.parseWebrtcDetectedBrowser = function () {
  var hasMatch, checkMatch = navigator.userAgent.match(
    /(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
  if (/trident/i.test(checkMatch[1])) {
    hasMatch = /\brv[ :]+(\d+)/g.exec(navigator.userAgent) || [];
    webrtcDetectedBrowser = &#x27;IE&#x27;;
    webrtcDetectedVersion = parseInt(hasMatch[1] || &#x27;0&#x27;, 10);
  } else if (checkMatch[1] === &#x27;Chrome&#x27;) {
    hasMatch = navigator.userAgent.match(/\bOPR\/(\d+)/);
    if (hasMatch !== null) {
      webrtcDetectedBrowser = &#x27;opera&#x27;;
      webrtcDetectedVersion = parseInt(hasMatch[1], 10);
    }
  }
  if (navigator.userAgent.indexOf(&#x27;Safari&#x27;)) {
    if (typeof InstallTrigger !== &#x27;undefined&#x27;) {
      webrtcDetectedBrowser = &#x27;firefox&#x27;;
    } else if (/*@cc_on!@*/ false || !!document.documentMode) {
      webrtcDetectedBrowser = &#x27;IE&#x27;;
    } else if (
      Object.prototype.toString.call(window.HTMLElement).indexOf(&#x27;Constructor&#x27;) &gt; 0) {
      webrtcDetectedBrowser = &#x27;safari&#x27;;
    } else if (!!window.opera || navigator.userAgent.indexOf(&#x27; OPR/&#x27;) &gt;= 0) {
      webrtcDetectedBrowser = &#x27;opera&#x27;;
    } else if (!!window.chrome) {
      webrtcDetectedBrowser = &#x27;chrome&#x27;;
    }
  }
  if (!webrtcDetectedBrowser) {
    webrtcDetectedVersion = checkMatch[1];
  }
  if (!webrtcDetectedVersion) {
    try {
      checkMatch = (checkMatch[2]) ? [checkMatch[1], checkMatch[2]] :
        [navigator.appName, navigator.appVersion, &#x27;-?&#x27;];
      if ((hasMatch = navigator.userAgent.match(/version\/(\d+)/i)) !== null) {
        checkMatch.splice(1, 1, hasMatch[1]);
      }
      webrtcDetectedVersion = parseInt(checkMatch[1], 10);
    } catch (error) { }
  }
};

/**
 * To fix configuration as some browsers does not support
 *  the &#x27;urls&#x27; attribute.
 * @property maybeFixConfiguration
 * @type Function
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.maybeFixConfiguration = function (pcConfig) {
  if (pcConfig === null) {
    return;
  }
  for (var i = 0; i &lt; pcConfig.iceServers.length; i++) {
    if (pcConfig.iceServers[i].hasOwnProperty(&#x27;urls&#x27;)) {
      pcConfig.iceServers[i].url = pcConfig.iceServers[i].urls;
      delete pcConfig.iceServers[i].urls;
    }
  }
};

/**
 * Adds an event listener for Temasys plugin objects.
 * @property addEvent
 * @type Function
 * @private
 * @for AdapterJS
 * @since 0.10.5
 */
AdapterJS.addEvent = function(elem, evnt, func) {
  if (elem.addEventListener) { // W3C DOM
    elem.addEventListener(evnt, func, false);
  } else if (elem.attachEvent) {// OLD IE DOM
    elem.attachEvent(&#x27;on&#x27; + evnt, func);
  } else { // No much to do
    elem[evnt] = func;
  }
};

/**
 * Detected webrtc implementation. Types are:
 * - &#x27;moz&#x27;: Mozilla implementation of webRTC.
 * - &#x27;webkit&#x27;: WebKit implementation of webRTC.
 * - &#x27;plugin&#x27;: Using the plugin implementation.
 * @property webrtcDetectedType
 * @type String
 * @readOnly
 * @for AdapterJS
 * @since 0.10.5
 */
webrtcDetectedType = null;

/**
 * Detected webrtc datachannel support. Types are:
 * - &#x27;SCTP&#x27;: SCTP datachannel support.
 * - &#x27;RTP&#x27;: RTP datachannel support.
 * @property webrtcDetectedType
 * @type String
 * @readOnly
 * @for AdapterJS
 * @since 0.10.5
 */
webrtcDetectedDCSupport = null;

/**
 * Set the settings for creating DataChannels, MediaStream for
 *   Cross-browser compability. This is only for SCTP based support browsers.
 * @method checkMediaDataChannelSettings
 * @param {String} peerBrowserAgent The browser agent name.
 * @param {Integer} peerBrowserVersion The browser agent version.
 * @param {Function} callback The callback that gets fired once the function is
 *   completed.
 * @param {JSON} constraints The RTCOfferOptions.
 * @return {Boolean &amp; JSON} (beOfferer, updatedConstraints)
 *   Returns a flag beOfferer if the peer should be the offer and also the updated unified
 *   RTCOfferOptions constraints.
 * @readOnly
 * @global true
 * @for AdapterJS
 * @since 0.10.5
 */
checkMediaDataChannelSettings = function (peerBrowserAgent, peerBrowserVersion, callback, constraints) {
  if (typeof callback !== &#x27;function&#x27;) {
    return;
  }
  var beOfferer = true;
  var isLocalFirefox = webrtcDetectedBrowser === &#x27;firefox&#x27;;
  // Nightly version does not require MozDontOfferDataChannel for interop
  var isLocalFirefoxInterop = webrtcDetectedType === &#x27;moz&#x27; &amp;&amp; webrtcDetectedVersion &gt; 30;
  var isPeerFirefox = peerBrowserAgent === &#x27;firefox&#x27;;
  var isPeerFirefoxInterop = peerBrowserAgent === &#x27;firefox&#x27; &amp;&amp;
    ((peerBrowserVersion) ? (peerBrowserVersion &gt; 30) : false);

  // Resends an updated version of constraints for MozDataChannel to work
  // If other userAgent is firefox and user is firefox, remove MozDataChannel
  if ((isLocalFirefox &amp;&amp; isPeerFirefox) || (isLocalFirefoxInterop)) {
    try {
      delete constraints.mandatory.MozDontOfferDataChannel;
    } catch (error) {
      console.error(&#x27;Failed deleting MozDontOfferDataChannel&#x27;);
      console.error(error);
    }
  } else if ((isLocalFirefox &amp;&amp; !isPeerFirefox)) {
    constraints.mandatory.MozDontOfferDataChannel = true;
  }
  if (!isLocalFirefox) {
    // temporary measure to remove Moz* constraints in non Firefox browsers
    for (var prop in constraints.mandatory) {
      if (constraints.mandatory.hasOwnProperty(prop)) {
        if (prop.indexOf(&#x27;Moz&#x27;) !== -1) {
          delete constraints.mandatory[prop];
        }
      }
    }
  }
  // Firefox (not interopable) cannot offer DataChannel as it will cause problems to the
  // interopability of the media stream
  if (isLocalFirefox &amp;&amp; !isPeerFirefox &amp;&amp; !isLocalFirefoxInterop) {
    beOfferer = false;
  }
  callback(beOfferer, constraints);
};

/**
 * Handles the differences for all browsers ice connection state output.
 * Tested outcomes are:
 * - Chrome (offerer)  : &#x27;checking&#x27; &gt; &#x27;completed&#x27; &gt; &#x27;completed&#x27;
 * - Chrome (answerer) : &#x27;checking&#x27; &gt; &#x27;connected&#x27;
 * - Firefox (offerer) : &#x27;checking&#x27; &gt; &#x27;connected&#x27;
 * - Firefox (answerer): &#x27;checking&#x27; &gt; &#x27;connected&#x27;
 * @method checkIceConnectionState
 * @param {String} peerId The peerId of the peer to check.
 * @param {String} iceConnectionState The peer&#x27;s current ICE connection state.
 * @param {String} callback The callback that returns the updated connected state.
 * @return {String} (state)
 * Returns the updated ICE connection state.
 * @for AdapterJS
 * @since 0.10.5
 */
checkIceConnectionState = function (peerId, iceConnectionState, callback) {
  if (typeof callback !== &#x27;function&#x27;) {
    console.warn(&#x27;No callback specified in checkIceConnectionState. Aborted.&#x27;);
    return;
  }
  peerId = (peerId) ? peerId : &#x27;peer&#x27;;

  if (!AdapterJS._iceConnectionFiredStates[peerId] ||
    iceConnectionState === AdapterJS._iceConnectionStates.disconnected ||
    iceConnectionState === AdapterJS._iceConnectionStates.failed ||
    iceConnectionState === AdapterJS._iceConnectionStates.closed) {
    AdapterJS._iceConnectionFiredStates[peerId] = [];
  }
  iceConnectionState = AdapterJS._iceConnectionStates[iceConnectionState];
  if (AdapterJS._iceConnectionFiredStates[peerId].indexOf(iceConnectionState) &lt; 0) {
    AdapterJS._iceConnectionFiredStates[peerId].push(iceConnectionState);
    if (iceConnectionState === AdapterJS._iceConnectionStates.connected) {
      setTimeout(function () {
        AdapterJS._iceConnectionFiredStates[peerId]
          .push(AdapterJS._iceConnectionStates.done);
        callback(AdapterJS._iceConnectionStates.done);
      }, 1000);
    }
    callback(iceConnectionState);
  }
  return;
};
    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
